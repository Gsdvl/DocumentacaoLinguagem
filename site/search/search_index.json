{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"ast/","title":"AST","text":"<p>Documenta\u00e7\u00e3o da AST</p>"},{"location":"ast/#estrutura-da-ast-astc","title":"Estrutura da AST (<code>ast.c</code>)","text":"<p>Este mdulo implementa as funes de construo e gerenciamento da rvore de Sintaxe Abstrata (AST) da linguagem. Ele responsvel por representar a estrutura lgica do cdigo-fonte aps a anlise sinttica, permitindo que fases posteriores como anlise semntica e interpretao/executao sejam realizadas.</p>"},{"location":"ast/#estrutura-geral","title":"Estrutura Geral","text":"<ul> <li>Arquivo: <code>ast.c</code></li> <li>Cabealhos: <code>#include \"ast.h\"</code></li> <li>Uso de memria: Todas as alocaes so feitas via <code>malloc</code>, <code>realloc</code>, <code>strdup</code>, e liberadas com <code>free</code>.</li> <li>Origem da linha: Cada n da AST marcado com a varivel global <code>yylineno</code> (linha atual do lexer/parser).</li> </ul>"},{"location":"ast/#criao-de-ns-da-ast","title":"Criao de Ns da AST","text":"<p>Todos os ns so derivados de <code>AstNode</code> e criados com uma funo base: static AstNode* create_base_node(AstNodeType type, size_t size); Ela aloca memria, atribui o tipo do n e o nmero da linha.</p>"},{"location":"ast/#tipos-de-ns-literais","title":"Tipos de Ns Literais","text":"<p>| Funo | Tipo de N | Descrio | |----------------------------------|----------------------------------|----------------- -----------------------| | <code>create_int_literal_node(int)</code> | <code>NODE_TYPE_INT_LITERAL</code> | Representa um nmero inteiro. | | <code>create_float_literal_node(float)</code> | <code>NODE_TYPE_FLOAT_LITERAL</code> | Representa um nmero de ponto flutuante. | | <code>create_string_literal_node(char*)</code> | <code>NODE_TYPE_STRING_LITERAL</code> | Representa uma string. | | <code>create_identifier_node(char*)</code> | <code>NODE_TYPE_IDENTIFIER</code> | Representa um identificador (nome). |</p>"},{"location":"ast/#expresses","title":"Expresses","text":"<p>| Funo | Tipo de N | Descrio | |-----------------------------------------------|-----------------------------|--------- -----------------------------------| | <code>create_assignment_node(target, op, expr)</code> | <code>NODE_TYPE_ASSIGNMENT</code> | Atribuio com operador (ex: <code>+=</code>). | | <code>create_binary_op_node(left, op, right)</code> | <code>NODE_TYPE_BINARY_OP</code> | Operao binria (<code>+</code>, <code>-</code>, etc). | | <code>create_unary_op_node(op, operand)</code> | <code>NODE_TYPE_UNARY_OP</code> | Operao unria (<code>!</code>, <code>-</code>, etc). | | <code>create_expression_statement_node(expr)</code> | <code>NODE_TYPE_EXPRESSION_STATEMENT</code> | Expresso isolada como instruo. |</p>"},{"location":"ast/#blocos-e-controle-de-fluxo","title":"Blocos e Controle de Fluxo","text":"<p>| Funo | Tipo de N | Descrio | |---------------------------------------------|---------------------------|------------- ------------------------------| | <code>create_block_node(statements)</code> | <code>NODE_TYPE_BLOCK</code> | Bloco de mltiplas instrues. | | <code>create_if_statement_node(cond, then, else)</code>| <code>NODE_TYPE_IF_STATEMENT</code> | Condicional <code>if</code>/<code>else</code>. | | <code>create_while_node(cond, body)</code> | <code>NODE_TYPE_WHILE_LOOP</code> | Lao <code>while</code>. | | <code>create_for_node(init, cond, incr, body)</code> | <code>NODE_TYPE_FOR_LOOP</code> | Lao <code>for</code>. | | <code>create_break_statement_node()</code> | <code>NODE_TYPE_BREAK_STATEMENT</code> | Interrupo de lao. | | <code>create_return_statement_node(expr)</code> | <code>NODE_TYPE_RETURN_STATEMENT</code> | Retorno de funo. |</p>"},{"location":"ast/#entrada-e-sada","title":"Entrada e Sada","text":"<p>| Funo | Tipo de N | Descrio | |---------------------------------------|-----------------------------|----------------- -------------------------------| | <code>create_printf_node(fmt_str, args)</code> | <code>NODE_TYPE_PRINTF_STATEMENT</code> | Comando <code>printf</code> com mltiplos argumentos. | | <code>create_printf_id_node(id)</code> | <code>NODE_TYPE_PRINTF_ID</code> | Impresso direta de uma varivel. | | <code>create_input_node()</code> | <code>NODE_TYPE_INPUT</code> | Comando de entrada <code>input</code>. |</p>"},{"location":"ast/#arrays","title":"Arrays","text":"<p>| Funo | Tipo de N | Descrio | |------------------------------------------------|-----------------------------|-------- -----------------------------------| | <code>create_array_literal_node(elements)</code> | <code>NODE_TYPE_ARRAY_LITERAL</code> | Criao de vetor com valores literais. | | <code>create_array_access_node(array, index_expr)</code> | <code>NODE_TYPE_ARRAY_ACCESS</code> | Acesso a elemento do vetor. | | <code>create_array_assignment_node(array_access, expr)</code> | <code>NODE_TYPE_ASSIGNMENT</code> | Atribuio de valor a um ndice do vetor. |</p>"},{"location":"ast/#funes","title":"Funes","text":"<p>| Funo | Tipo de N | Descrio | |------------------------------------------------|-----------------------------|-------- -----------------------------------| | <code>create_function_declaration_node(name, body)</code>| <code>NODE_TYPE_FUNCTION_DECL</code> | Declarao de uma funo. | | <code>create_function_call_node(name, args)</code> | <code>NODE_TYPE_FUNCTION_CALL</code> | Chamada de funo. |</p>"},{"location":"ast/#estruturas-de-suporte","title":"Estruturas de Suporte","text":""},{"location":"ast/#astnodelist","title":"<code>AstNodeList</code>","text":"<p>Representa uma lista dinmica de ns da AST (como blocos de instrues ou arrays). - <code>create_ast_node_list_from_node(node)</code> - <code>append_to_ast_node_list(list, node)</code></p>"},{"location":"ast/#argumentnode","title":"<code>ArgumentNode</code>","text":"<p>Representa uma lista encadeada de argumentos de funo ou <code>printf</code>. - <code>create_argument_node(node)</code> - <code>free_argument_list(list)</code></p>"},{"location":"ast/#liberao-de-memria","title":"Liberao de Memria","text":"<p>A funo <code>free_ast(node)</code> percorre toda a rvore de forma recursiva e libera a memria alocada por: - Strings duplicadas (<code>strdup</code>) - Subns e listas - Argumentos Ela identifica o tipo de n via <code>node-&gt;type</code> e aplica a liberao correta para cada caso. Tambm imprime um erro padro caso o tipo seja desconhecido.</p>"},{"location":"ast/#observaes-importantes","title":"Observaes Importantes","text":"<ul> <li>A arquitetura separa bem a construo da AST do parsing.</li> <li>A AST projetada para preservar informao de linha, til para erros e debug.</li> <li>possvel expandir facilmente com novos tipos de ns seguindo o mesmo padro.</li> </ul>"},{"location":"ast/#exemplos-futuros","title":"Exemplos futuros","text":"<p>Em arquivos futuros, como o parser (<code>parser.y</code>) ou interpretador, voc pode usar chamadas como: AstNode n = create_binary_op_node(a, OP_PLUS, b); AstNode stmt = create_if_statement_node(cond, bloco1, bloco2); Esses ns so ento ligados rvore de forma recursiva e estruturada.</p>"},{"location":"lexer/","title":"\ud83d\udd11 Palavras Reservadas da Linguagem G2DL","text":"<p>Palavras reservadas s\u00e3o identificadores especiais que n\u00e3o podem ser usados como nomes de vari\u00e1veis, fun\u00e7\u00f5es ou objetos, pois possuem um significado fixo na linguagem. Elas fazem parte da gram\u00e1tica principal e s\u00e3o reconhecidas diretamente pelo analisador l\u00e9xico.</p> <p>Abaixo est\u00e1 a lista completa das palavras reservadas da linguagem G2DL, junto com uma descri\u00e7\u00e3o do papel de cada uma.</p>"},{"location":"lexer/#controle-de-fluxo","title":"\ud83e\udde0 Controle de Fluxo","text":"Palavra Fun\u00e7\u00e3o <code>if</code> Inicia uma estrutura condicional. Executa um bloco caso a condi\u00e7\u00e3o seja verdadeira. <code>else</code> Define o bloco alternativo de um <code>if</code> quando a condi\u00e7\u00e3o \u00e9 falsa. <code>while</code> Cria um la\u00e7o de repeti\u00e7\u00e3o baseado em uma condi\u00e7\u00e3o booleana. <code>for</code> Inicia um la\u00e7o com controle expl\u00edcito de vari\u00e1vel e intervalo. <code>break</code> Interrompe a execu\u00e7\u00e3o do la\u00e7o mais pr\u00f3ximo (<code>for</code> ou <code>while</code>)."},{"location":"lexer/#funcoes-e-retornos","title":"\ud83e\uddee Fun\u00e7\u00f5es e Retornos","text":"Palavra Fun\u00e7\u00e3o <code>function</code> Define uma fun\u00e7\u00e3o com nome, par\u00e2metros e corpo execut\u00e1vel. <code>return</code> Finaliza a fun\u00e7\u00e3o atual e retorna um valor opcional ao chamador."},{"location":"lexer/#valores-literais","title":"\ud83d\udd22 Valores Literais","text":"Palavra Fun\u00e7\u00e3o <code>true</code> Literal booleano verdadeiro. <code>false</code> Literal booleano falso."},{"location":"lexer/#entrada-e-saida","title":"\ud83d\udda8\ufe0f Entrada e Sa\u00edda","text":"Palavra Fun\u00e7\u00e3o <code>printf</code> Fun\u00e7\u00e3o nativa para exibir dados no terminal (semelhante \u00e0 <code>printf</code> em C). <code>input</code> Solicita entrada do usu\u00e1rio e retorna como string."},{"location":"lexer/#observacoes","title":"\ud83d\udee1\ufe0f Observa\u00e7\u00f5es","text":"<ul> <li>Todas essas palavras s\u00e3o reconhecidas diretamente pelo lexer e n\u00e3o exigem nenhuma declara\u00e7\u00e3o pr\u00e9via.</li> <li>Elas n\u00e3o podem ser sobrescritas (por exemplo, n\u00e3o \u00e9 poss\u00edvel criar uma fun\u00e7\u00e3o chamada <code>if</code>).</li> <li>S\u00e3o case-sensitive (sens\u00edveis a mai\u00fasculas/min\u00fasculas). Portanto, <code>If</code> ou <code>ELSE</code> n\u00e3o s\u00e3o v\u00e1lidas.</li> </ul>"},{"location":"lexer/#exemplo-de-uso","title":"\ud83e\uddea Exemplo de uso","text":"<p>```bash function somar(a, b) {     if (a &gt; b) {         printf(\"a \u00e9 maior\");     } else {         printf(\"b \u00e9 maior ou igual\");     }     return a + b; }</p>"}]}